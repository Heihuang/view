/*
题目：请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）
解法：动态规划
假设主串为 A，模式串为B从最后一步出发，需要关注最后进来的字符。假设A的长度为n，B的长度为m，
关注正则表达式B的最后一个字符是谁，它有三种可能，正常字符、*∗ 和 .（点），那针对这三种情况讨论即可，如下：
1、如果B的最后一个字符是正常字符，那就是看A[n-1]是否等于B[m-1],相等则看A0...An-2与B0...Bm-2,不等则是不能匹配，这就是子问题
2、如果B的最后一个字符是.,它能匹配任意字符，直接看看A0...An-2与B0...Bm-2
3、如果B的最后一个字符是*它代表B[m-2]=c可以重复0次或多次，它们是一个整体c*
情况一：A[n-1]是0个c，B最后两个字符废了，能否匹配取决与A0...An-1和B0...Bm-3是否匹配
情况二：A[n-1]是多个c中的最后一个(这种情况必须A[n-1]=c或者c='.')，所以A匹配往前挪一个，B继续匹配，因为可以匹配多个，
继续看A0...n-2和B0..Bm-1是否匹配。
转移方程：
f[i][j]代表A的前i个和B的前j个能否匹配
对于前面两个情况，可以合并成一种情况 f[i][j] = f[i-1][j-1]
对于第三种情况，对于c*分为看和不看两种情况
不看：直接砍掉正则串的后面两个，f[i][j]=f[i][j-2]
看：正则串不动，主串前移一个，f[i][j] = f[i-1][j]
特判：需要考虑空串空正则
空串和空正则是匹配的，f[0][0] = true
空串和非空正则，不能直接定义 true和false，必须要计算出来。（比如A='' ,B=a*b*c*）
非空串和空正则必不匹配，f[1][0]=...=f[n][0]=false
非空串和非空正则，那肯定是需要计算的了
*/
#include <string>
#include <vector>
using namespace std;

bool isMatch(string s, string p) {
    int size = s.size();
    int psize = p.size();
    vector<vector<bool>> dp(size + 1, vector<bool>(psize + 1, false));
    dp[0][0] = true;
    for(int i = 0; i <= size; i++){
        for(int j = 1; j <= psize; j++){
            if(p[j-1] != '*'){
                dp[i][j] = (i > 0 && (p[j-1] == s[i-1] || p[j-1] == '.')) && dp[i-1][j-1];
            }else{
                dp[i][j] = (j >= 2) && (dp[i][j-2] || ( (i >= 1) && dp[i-1][j] && (p[j-2] == '.' || p[j-2] == s[i-1]) ) );
                // dp[i][j] = dp[i][j] || ( (j >= 2) && (dp[i][j-2]) );  // s not consumed
                // dp[i][j] = dp[i][j] || ( (j >= 2) && (i >= 1) && dp[i-1][j] && (p[j-2] == '.' || p[j-2] == s[i-1]) ); // s consumed
            }
        }
    }
    return dp[size][psize];
}


